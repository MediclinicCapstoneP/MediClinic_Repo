-- ==================================================\n-- QUICK SETUP: DOCTOR APPOINTMENT FIXES\n-- ==================================================\n-- This script contains the essential fixes for doctor appointment visibility\n-- Run this in your Supabase SQL editor or database management tool\n\n-- STEP 1: Quick Analysis\nSELECT 'BEFORE FIXES - Data Analysis' as step;\nSELECT \n    COUNT(*) as total_appointments,\n    COUNT(doctor_id) as with_doctor_id,\n    COUNT(doctor_name) as with_doctor_name,\n    COUNT(*) - COUNT(doctor_id) as missing_doctor_id\nFROM appointments;\n\n-- Show some sample appointments with missing doctor_id\nSELECT 'Sample appointments missing doctor_id:' as info;\nSELECT id, doctor_name, patient_name, appointment_date, status\nFROM appointments \nWHERE doctor_name IS NOT NULL AND doctor_id IS NULL\nLIMIT 5;\n\n-- Show all doctors in the system\nSELECT 'All doctors in system:' as info;\nSELECT id, full_name, email, specialization FROM doctors ORDER BY full_name;\n\n-- STEP 2: Fix doctor_id by matching names\nUPDATE appointments \nSET doctor_id = doctors.id,\n    updated_at = NOW()\nFROM doctors \nWHERE appointments.doctor_name IS NOT NULL \nAND appointments.doctor_id IS NULL \nAND (\n    LOWER(TRIM(appointments.doctor_name)) = LOWER(TRIM(doctors.full_name))\n    OR LOWER(TRIM(REPLACE(appointments.doctor_name, 'dr.', ''))) = LOWER(TRIM(doctors.full_name))\n    OR LOWER(TRIM(appointments.doctor_name)) = LOWER(TRIM(CONCAT('dr. ', doctors.full_name)))\n    OR LOWER(TRIM(appointments.doctor_name)) LIKE LOWER(TRIM(CONCAT('%', doctors.full_name, '%')))\n    OR LOWER(TRIM(doctors.full_name)) LIKE LOWER(TRIM(CONCAT('%', appointments.doctor_name, '%')))\n);\n\n-- STEP 3: Create helper function\nCREATE OR REPLACE FUNCTION resolve_doctor_id_from_name(input_doctor_name TEXT)\nRETURNS UUID AS $$\nDECLARE\n    found_doctor_id UUID;\n    normalized_input TEXT;\nBEGIN\n    IF input_doctor_name IS NULL OR TRIM(input_doctor_name) = '' THEN\n        RETURN NULL;\n    END IF;\n    \n    normalized_input := LOWER(TRIM(input_doctor_name));\n    \n    -- Try exact match\n    SELECT id INTO found_doctor_id\n    FROM doctors \n    WHERE LOWER(TRIM(full_name)) = normalized_input\n    LIMIT 1;\n    \n    IF found_doctor_id IS NOT NULL THEN\n        RETURN found_doctor_id;\n    END IF;\n    \n    -- Try without \"Dr.\" prefix\n    SELECT id INTO found_doctor_id\n    FROM doctors \n    WHERE LOWER(TRIM(full_name)) = LOWER(TRIM(REPLACE(normalized_input, 'dr.', '')))\n       OR LOWER(TRIM(CONCAT('dr. ', full_name))) = normalized_input\n    LIMIT 1;\n    \n    IF found_doctor_id IS NOT NULL THEN\n        RETURN found_doctor_id;\n    END IF;\n    \n    -- Try partial match\n    SELECT id INTO found_doctor_id\n    FROM doctors \n    WHERE LOWER(TRIM(full_name)) LIKE CONCAT('%', normalized_input, '%')\n       OR normalized_input LIKE CONCAT('%', LOWER(TRIM(full_name)), '%')\n    LIMIT 1;\n    \n    RETURN found_doctor_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- STEP 4: Fix any remaining appointments\nUPDATE appointments \nSET doctor_id = resolve_doctor_id_from_name(doctor_name),\n    updated_at = NOW()\nWHERE doctor_name IS NOT NULL \nAND doctor_id IS NULL;\n\n-- STEP 5: Create auto-population trigger\nCREATE OR REPLACE FUNCTION auto_populate_doctor_id()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.doctor_id IS NULL AND NEW.doctor_name IS NOT NULL THEN\n        NEW.doctor_id := resolve_doctor_id_from_name(NEW.doctor_name);\n    END IF;\n    \n    IF NEW.doctor_id IS NOT NULL AND (NEW.doctor_name IS NULL OR NEW.doctor_name = '') THEN\n        SELECT full_name INTO NEW.doctor_name\n        FROM doctors \n        WHERE id = NEW.doctor_id;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS trigger_auto_populate_doctor_id ON appointments;\nCREATE TRIGGER trigger_auto_populate_doctor_id\n    BEFORE INSERT OR UPDATE ON appointments\n    FOR EACH ROW\n    EXECUTE FUNCTION auto_populate_doctor_id();\n\n-- STEP 6: Create indexes for better performance\nCREATE INDEX IF NOT EXISTS idx_appointments_doctor_id_date \n    ON appointments(doctor_id, appointment_date) \n    WHERE doctor_id IS NOT NULL;\n\nCREATE INDEX IF NOT EXISTS idx_appointments_doctor_id_status \n    ON appointments(doctor_id, status) \n    WHERE doctor_id IS NOT NULL;\n\n-- STEP 7: Create stored procedure for optimized queries\nCREATE OR REPLACE FUNCTION get_doctor_appointments(\n    input_doctor_id UUID,\n    filter_status TEXT DEFAULT NULL,\n    filter_date DATE DEFAULT NULL,\n    limit_results INTEGER DEFAULT NULL\n)\nRETURNS TABLE(\n    appointment_id UUID,\n    patient_id UUID,\n    patient_name TEXT,\n    appointment_date DATE,\n    appointment_time TIME,\n    appointment_type TEXT,\n    status TEXT,\n    notes TEXT,\n    doctor_notes TEXT,\n    clinic_id UUID,\n    clinic_name TEXT,\n    duration_minutes INTEGER,\n    payment_amount NUMERIC\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        a.id as appointment_id,\n        a.patient_id,\n        COALESCE(\n            a.patient_name,\n            CONCAT(p.first_name, ' ', p.last_name),\n            CONCAT('Patient ID: ', SUBSTRING(a.patient_id::text, 1, 8)),\n            'Unknown Patient'\n        ) as patient_name,\n        a.appointment_date,\n        a.appointment_time,\n        a.appointment_type,\n        a.status,\n        a.notes,\n        a.doctor_notes,\n        a.clinic_id,\n        c.clinic_name,\n        a.duration_minutes,\n        a.payment_amount\n    FROM appointments a\n    LEFT JOIN patients p ON a.patient_id = p.id\n    LEFT JOIN clinics c ON a.clinic_id = c.id\n    WHERE a.doctor_id = input_doctor_id\n    AND (filter_status IS NULL OR a.status = filter_status)\n    AND (filter_date IS NULL OR a.appointment_date = filter_date)\n    ORDER BY a.appointment_date ASC, a.appointment_time ASC\n    LIMIT COALESCE(limit_results, 1000);\nEND;\n$$ LANGUAGE plpgsql;\n\n-- STEP 8: Create view for easy queries\nCREATE OR REPLACE VIEW doctor_appointments_view AS\nSELECT \n    a.*,\n    d.full_name as resolved_doctor_name,\n    d.specialization as doctor_specialty,\n    p.first_name as patient_first_name,\n    p.last_name as patient_last_name,\n    COALESCE(\n        a.patient_name,\n        CONCAT(p.first_name, ' ', p.last_name),\n        CONCAT('Patient ID: ', SUBSTRING(a.patient_id::text, 1, 8))\n    ) as resolved_patient_name,\n    c.clinic_name,\n    c.address as clinic_address\nFROM appointments a\nLEFT JOIN doctors d ON a.doctor_id = d.id\nLEFT JOIN patients p ON a.patient_id = p.id\nLEFT JOIN clinics c ON a.clinic_id = c.id;\n\n-- STEP 9: Verify the fixes\nSELECT 'AFTER FIXES - Data Analysis' as step;\nSELECT \n    COUNT(*) as total_appointments,\n    COUNT(doctor_id) as with_doctor_id,\n    COUNT(doctor_name) as with_doctor_name,\n    COUNT(*) - COUNT(doctor_id) as still_missing_doctor_id\nFROM appointments;\n\n-- Show appointments by doctor\nSELECT 'Appointments per doctor:' as info;\nSELECT \n    d.full_name as doctor_name,\n    COUNT(a.id) as appointment_count\nFROM doctors d\nLEFT JOIN appointments a ON d.id = a.doctor_id\nGROUP BY d.id, d.full_name\nORDER BY appointment_count DESC;\n\n-- Test the stored procedure (replace with actual doctor ID)\nSELECT 'Test stored procedure (replace doctor_id):' as info;\n-- SELECT * FROM get_doctor_appointments('your-doctor-id-here'::uuid) LIMIT 5;\n\n-- ==================================================\n-- SETUP COMPLETE\n-- ==================================================\n-- Your doctor appointment system should now work properly!\n-- The fixes include:\n-- 1. Populated missing doctor_id fields\n-- 2. Created auto-population triggers for future appointments\n-- 3. Added performance indexes\n-- 4. Created optimized stored procedure and view\n-- 5. Enhanced patient name resolution\n-- ==================================================